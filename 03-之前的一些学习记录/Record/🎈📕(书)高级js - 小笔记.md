{{javascript高级程序设计}}[toLocaleString()],[toString()],[valueOf()]

😊😊😊😊😊😊😊😊《第二章》😊😊😊😊😊😊😊😊😊
defer='defer'  [延迟脚本 附加在```<script>```里]
asyne          [异步脚本 - 同时加载]



🧡🧡🧡🧡🧡🧡🧡🧡《第三章》🧡🧡🧡🧡🧡🧡🧡🧡
(strict mode)  [严格模式]
"use strict";     //-只顶部加入严格模式|可以也只指定的函数里加入严格模式

如果var出现只函数里 那他声明的这个变量只会出现只这个函数里,
如果在外部调用这个变量,会报错.
如果想在外部调用函数里端变量 声明的时候可以不带var //但是不推荐这样做.
但是,如果是只if 判断语句中声明, 倒是可以在外部调用声明的这个变量.



\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

[ 一元操作符(操作一个值的就叫一元操作符(自增\自减) 位操作符(略)]
[布尔操作符(略)(与或非那些内容...)]
[乘性操作符(乘法\除法\求模[就是除余]) (Infinity 代表无穷大) (-Infinity 无穷小)]
[加性操作符...]
[关系操作符 (大于>)(小于<)(大于等于>=)(小于等于<=)]
[相等操作符(等于==)(不等于!=)]
[条件操作符 (三元运算符    (num1 > num2 )? num1 : num2;)]
[赋值操作符 = 或者 += -= *= %= /= <<=  >>=]
[逗号操作符 , ]


{{ [if语句],[do-while],[while],[for],[for-in],[label],[break],[continue]}}

[break;  跳出后就不会执行后面的了并且跳出'循环']
[continue; 跳出后也不会执行后面的,  但是会返回'循环' ,只是跳出那一次而已]
[with 将代码的作用域设置到一个特定的对象中   (貌似不用了)]
    with(前面声明变量赋值的前缀){
        var qs = (上面的前缀会在这里) 什么什么什么
        var url= (上面的前缀会在这里) 什么什么什么2
    }
[switch - case ]
/////////////////////////////////////////////////////////////////////

《第四章》
一.基本类型和引用类型的
!{不能给基本类型的值添加属性,}

typeof [检测基本类型]
instanceof [检测应用类型 123 instanceof number]

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

二.执行环境及作用域
[全局执行环境是最外围的一个执行环境 (在Web浏览器中 是 window对象)]
[某个环境中的所有代码执行完成后,该环境被摧毁,保存在其中的所有变量和函数定义也随之摧毁]
(关闭网页或浏览器 - 摧毁全局执行环境)

[每个函数都有直接的执行环境,当执行流进入一个函数时,函数的环境就会被推入一个环境栈中]
[而在函数执行之后,栈将其环境弹出,把控制权返回给之前的执行环境]
\
\
{{{--- 作用域链 ---}}}
[当代码在一个环境中执行时,会创建变量对象的一个作用域连]
[作用域链用途:保证对执行环境有权访问的所有变量 和 函数的有序访问]
[作用域链的前端,始终都是当前执行代码所在环境的变量对象,]
[如果这个环境是函数,则将其活动对象(activation object)作为变量对象]
[活动对象在最开始时只包含一个变量 即arguments对象(这个对象在全局环境中是不存在的) ]

[作用域链中的下一个变量对象来自包含(外部)环境,而再下一个变量对象则来自下一个包含环境]
[这样-一直延续到全局执行环境;全局执行环境的变量对象始终都是作用域链中最后一个对象]

//////////////////////////////
[局部作用域中定义的变量可以在局部环境与全局变量互换使用]

{函数内部的对象 还有一个是this}
arguments.length [参数的长度]
arguments [转入的参数]
//////////////////////////////////////////////////////////////
{{{{说白了 所谓的'作用域链'就是 局部可以访问 '外部'或'全局' 
但是'外部'或'全局'没办法访问到'局部'里面 定义的变量
这样的一条关系链, 我xxg 称之为 <作用域链~>}}}}
/////////////////////////////////////////////////////////////

{延长作用域链}
[wry-carch语句中的catch块]
[with语句]
/////////////////////////////////
{没有块级作用域}
声明的变量 不会在'if判断语句'中被摧毁,
所以在外部可以调用
[在JavaScript中if语句的变量声明会将变量添加到if语句的执行环境中 for也是]

{{这一点在ES6当中有改善 let 声明}}
/////////////////////////////////////////////////////////////////
[如果初始化变量时没有使用'var' 则会被添加到"全局环境"中变成'全局变量']
//////////////////////////////////////////////////////////////////


《第五章》
[new操作符]
//////////////////////////{ 对象Object }////////////////////
    1. 对象 = new操作符 + 构造函数(就是函数){比如Object}
    2.[对象字面量表示法] 
        var 变量 = {对象}
        (例如: var person= {
                name : 'xxg',
                age  : 18
                }             
    对象方法:[toLocaleString()],[toString()],[valueOf()]


/////////////////////////{ 数组Array }/////////////////////////////


///////////////////////////{ 时间Date }//////////////////////////


/////////////////////////{ RegExp类型 }(用来支持正则表达式)////////////


///////////////////////////{Function类型}/////////////////////////


/////////////////////////////////////////////////////////////////////////////



《第六章》
/////---{ 面向对象的程序设计 }---//////
OO(Object-Oriented)(类的概念)
ECMA-262把'对象'定义为"无序属性的集合,其属性可以包含基本值,对象,函数"
一.理解对象!
[对象字面量 写法成首选]

{一.1 '属性类型'}
对象两个属性:Object.defineProperty()
1.数据属性:(只有内部采用的特性(attribute)时,描述了属性(property)的各种特征.)
            (为了表示特性是内部值,规范把他们放在了两对儿方括号中,例如[[Enumerable]].)

[[Configurable]] (能否通过delete删除属性,能否修改属性特性,能否修改为访问器属性 [默认都是true])
[[Enumerable]]   (能否通过for-in 循环返回属性[默认也是true])
[[Writable]]     (能否修改属性的值[默认true])
[[Value]]        (包含这个属性的数据值,)

可以多次调用Object.defineProperty()方法修改同一个属性,但在把configurable特性设置为false之后就会有限制了

2.访问器属性:(访问属性不包含数据值,它们包含一对儿getter[返回有效值]和setter[传入新值]函数,)
[[Configurable]]
[[Enumerable]]
[[Get]]         (读取属性时调用的函数,默认undefined)
[[Set]]         (写入属性时调用的函数,默认undefined)

(访问器属性不能直接定义,必须使用Object.defineProperty()来定义)
[ _ 下划线是一种常用的记号, 用于表示只能通过对象方法访问的属性 ]
(设置一个属性的值会导致其他属性发生变化)

[要创建访问器属性,一般使用两个非标准的方法, [__defineGetter__()][__defineSetter__()]]

[在不支持Object.defineProperty()方法的浏览器中不能修改[[Configurable]],[[Enumerable]] ]

/////////////////////////////////////////////////////////////////////////////////////////

{一.2 '定义多个属性'}
Object.defineProperties() [描述一次定义多个属性,接受两个参数:(添加和修改其属性的对象),(与第一个添加或修改的属性一一对应)]
{这里的属性是同一时间创建的}

/////////////////////////////////////////////////////////////////////////////////////

{一.3 '读取属性的特性'}
Object.getOwnPropertyDescriptor()方法 [取得给定属性的描述符,两个参数:(属性所在的对象)和(要读取其描述符的属性名称)]
[返回值是一个对象]
[如果是访问属性: 对象属性有{ [[Configurable]] - [[Enumerable]] - [[Get]] - [[Set]] }
[如果是数据属性: 对象属性有{ [[Configurable]] - [[Enumerable]] - [[Writable]] - [[Value]]  }


//////////////////////////////////////////////////////////////////////////////////////////

二.创建对象
[由于使用一个接口创建很多对象,会产生大量重复代码,为了解决这个问题 人们开始使用"工厂模式"的一种变体]
"工厂模式" [用函数来封装以特定接口创建对象的细节]
['工厂模式'虽然解决了创建多个相似对象的问题,但却没有解决对象识别的问题!(即怎样知道一个对象的类型)]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
['构造函数模式']
(创建自定义的构造函数, 定义自定义对象类型的属性和方法)
(按照惯例, 构造函数始终都应该以一个大写字母开头,)
(要创建 新实例, 必须使用 new 操作符)
1)创建一个新对象;
2)将构造函数的作用域赋给新对象(因此this就指向了这个新对象)
3)执行构造函数中的代码(为这个新对象添加属性);
4)返回新对象
[创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型;而这正是'构造函数模式'胜过'工厂模式'的地方]

////////////////////////////////////

[1. 将构造函数当作函数]

[3. "原型模式"]
(我们创建的每一个函数都有一个prototype(原型)属性, 是一个指针,指向一个对象)




//////////////////////////////////////////////////////////////////////
《第七章》
[ 函数表达式 ]
1."函数声明" :
    function xxx(){
        var name = xxg
    }
[首先是function关键字 然后是函数的名字 (这就是"指定函数名"的方式)]
[可以通过这个属性访问到函数指定的名字,这个属性的值永远等于跟在function关键字后面的标识符]

比如: alert(xxx.name);
//////////////////////////////////////////
['函数声明提升'] (可以把函数声明放在 调用它的语句后面)
////////////////////////////////////////////

2."函数表达式" (匿名函数,拉姆达函数,   name属性是空字符串)
    var lalala = function(){

    }
[没有提升, 所以得先赋值 再调用]
/////////////////////////////////////////////////////////////////

{{'函数表达式'跟'函数声明'的区别}}
在'if' 和'else'中分别生产了两个相同名字的'函数声明'会报错
                用'函数表达式'来赋值就不会, 


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮[ "闭包" ]🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮🔮
{匿名函数} != {闭包}
👇['闭包' 是指有权访问另一个函数作用域中的变量的函数,创建闭包就是在一个函数内部创建另一个函数]

    function createComparisonFunction(propertyName){

        return function (obj1 , obj2 ){
            var value1 = obj1[propertyName];
            var value2 = obj2[propertyName];

            if (value1 < value2){
                return -1;
            }else if(value1 > value2){
                return 1;
            }else{
                return 0;
            }
        };
    }

👇['闭包与变量']
[闭包只能取得包含函数中任何变量的最后一个值]
[闭包左保存的是整个变量对象,而不是某个特殊的变量]




[关于this对象]

[内存泄漏]

[模仿块级作用域]
    [私有变量]
    [静态私有变量]
    [模块模式]
    [增强的模块模式]


/////////////////////// 第八章 BOM /////////////////////////
《第八章》 BOM

[window对象]
    [全局作用域]
    {全局变量不能通过delete 操作符删除 , 而直接在window对象上的定义的属性可以}


[窗口关系及框架]
{每个框架都拥有自己的window对象,并保存在frames集合中,}
{每个window对象都有一个name属性}



[窗口位置]
    'screenLeft'和'screenTop'{分别表示窗口相对屏幕左边和上边}   
[窗口大小]
    'innerWidh'和'innerHeight'{页面视图区的大小/减去边框的框图}
    'outerWidth'和'outerHeight'{返回浏览器窗口本身的尺寸}
    (chrome中返回相同的值)
[导航和打开窗口]
    window.open('url地址',topFrame);
    {如果有一个名叫"topFrame"的窗口或者框架,就会在该窗口或框架加载这个url,否则,就会创建一个新窗口并将命名为"topFrame"}
.{此外,第二个参数也可以是下列如何一个特殊的窗口名称: _self_ | _parent | _top | _blank  };

[弹出窗口]
[弹出窗口屏蔽程序]

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


[间歇调用]和[超时调用]
['每隔指定的时间就执行一次代码' | '指定的时间过后执行代码']
就是所谓的['更新器']和['倒数器']

👇[超时][倒数]👇
{'setTimeout'}[接收两个参数:1.(要执行的代码),2.(执行代码前需要等待多少毫秒)]
👉[取消定时器] - clearTimeout()

👇[间歇][更新]👇
{'setInterval'}[接收两个参数:1.(要执行的代码),2.(每次执行需要等待多少毫秒)]
👉[取消更新器] - clearInterval()

/////////////////////////////////////////////////////////////////

[系统对话框]

['alert()'] - 消息弹窗
['confirm()'] - 确认\取消弹窗 - 会返回布尔值
['prompt()'] - 输入对话框


///////////////////////////////////////////////////////////////////

[location对象] - 是最有用的BOM对象之一

{它提供了当前窗口中加载的文档有关的信息,它既是window对象的属性,也是document对象的属性,
window.location 和 document.location 引用的是同一个对象.  }


location - 前缀👇
hash - 返回url中的hash #号后跟0 或 多个字符
host - 返回服务器名称和端口号(如果有)
hostname - 返回服务器名称
href - 返回当前加载页面的完整URL
pathname - 返回URL中的目录 和(或) 文件名
port - 返回URL中指定的端口号,如果URL中不包含端口号,则这个属性返回空字符串
protocol - 返回页面使用的协议(http:或https:)
search - 返回URL的查询字符串(以问号开头)

///////////////////////////////////////////////

[查询字符串参数]

//////////////////////////////////

[位置操作]

location.assign(传递一个URL) {与下面两个一样效果}
window.location = 'URL'
location.href = 'URL'
location.reload('URL')

///////////////////////////////////////

[ navigator对象 ]
    
appCodeName  -  浏览器名称

appMinorVersion  -  次版本信息

appVersion  -  完整浏览器名称

buildID  -  浏览器版本

cookieEnabled  -  表示cookie是否开启

cpuClass  -  客户端计算机使用的cpu

javaEnabled()  -  表示当前浏览器是否启用了java

language  -  浏览器主语言

mimeTypes  -  浏览器中注册的MIME类型数组

onLine  -  是否连接到了因特网

opsProfile  -  ....(查不到相关文档)

oscpu  -  客户端计算机的操作系统或使用的cpu

Platform  -  浏览器所在的系统平台

plugins  -  浏览器中安装的插件信息的数组

preference()  -  设置用户的首选项

product  -  产品名称(如Gecko)

productSub  -  关于产品的次要信息(如Gecko的版本)

register-ContentHandler()  -  针对特定的MIME类型将一个站点注册为处理程序

register-ProtocolHandler()  -  针对特定的协议将一个站点注册为处理程序

securityPolicy  -  已经废弃.安全策略的名称

systemLanguage  -  操作系统的语言

taintEnabled()  -  已经废弃, 表示变量被修改

" userAgent  -  浏览器的用户代理字符串 "

userLanguage  -  操作系统的默认语言

userProfile  -  借以访问用户个人信息的对象

vendor  -  浏览器的品牌

vendorSub  -  有关供应商的次要信息

////////////////////////////////////////////////////////////////

[检测插件]
对于非IE浏览器,可以使用 'plugins' 数组来检测

navigator.plugins //返回一个数组

navigator.plugins[i].name.toLowerCase().indexOf(name) 
//在这个数组中名字(小写化)  去 查找name值


///////////////////////////////////////////////

[注册处理程序] ???
////////////////////////////
[screen]对象 ???

//////////////////////////////////////////////////

[history]对象

history.go(-1); | history.back() //后退一页

history.go(1);  | history.forward()  //前进一页


////////////////////////////////////
小结重点:
    top对象始终指向最外围的框架,也就是整个浏览器窗口

    parent对象表示包含当前框架的框架,而self对象则回指window





/////////////////////// 第九章 客户端检测 /////////////////////////
《第九章》 客户端检测
["能力检测"\特性检测]
{识别浏览器的能力,只要确定浏览器支持的特定的能力}
.......

["怪癖检测",'怪癖'也就是bug]
......
"[用户代理检测]" - 还蛮重要的 (可以用来检测用户的浏览器呀 区别是电脑还是手机)
....



/////////////////////// 第十章 DOM /////////////////////////
《第十章》 DOM

[节点层次]
    [Node类型]
    [Document类型]
    [Element类型]   -   [HTML元素]
    [Text类型]
    [Comment类型]
    [CDATASection类型]
    [DocumentType类型]
    [DocumentFragment类型]
    [Attr类型]

[DOM操作技术]
    [动态脚本]
    [动态样式]
    [操作表格]

..........................[ 小结 ].......................



《第十一章》 DOM扩展


....暂时不知道做什么笔记...


/////////////////////////////////////////////////////////
《第十二章》 DOM2 和 DOM3
    ....
    [元素大小] - [偏移量(offset dimension)]
                    1. offsetHeight
                    2. offsetWidth
                    3. offsetLeft
                    4. offsetTop        
....[遍历]
....[范围]
....[]

////////////////////////////////////////////////////////////
《第十三章》 事件

[这章也是一样跳过,原因是之前已经有做过这类笔记了]



///////////////////////////////////////////////////////////////
《第十四章》 表单脚本

[这章也是一样跳过,原因是之前已经有做过这类笔记了]



///////////////////////////////////////////////////////////
《第十五章》 使用Canvas 绘图

[这章也是一样跳过,这个是html5的东西]



////////////////////////////////////////////////////////////
《第十六章》 HTML5脚本编程
HTML5的东西
[拖放事件]...
[音频跟视频]



///////////////////////////////////////////////////////////////
《第十七章》 错误处理与调试

[理解浏览器报告的错误]
[处理错误]
[调试JavaScript代码]



/////////////////////////////////////////////////////////////////////
《第十八章》 JavaScript 与 XML




/////////////////////////////////////////////////////////////////////////
《第十九章》E4X


////////////////////////////////////////////////////////////////////////
《第二十章》JSON 










